use std::{
    fs::File,
    io::{self, BufReader, Cursor, Read},
    path::Path,
};

#[derive(Debug)]
struct TkOutput {
    offsets: Vec<(u32, u32)>, // (offset, length) pairs
    values: Vec<u16>,
}

impl TkOutput {
    fn get(&self, i: u16) -> impl Iterator<Item = &u16> {
        let (offset, length) = self.offsets[i as usize];
        self.values.as_slice()[offset as usize..(offset + length) as usize].iter()
    }
}

#[derive(Debug)]
struct FlatArray<T> {
    cols: usize,
    data: Vec<T>,
}

impl<T> FlatArray<T> {
    fn new(rows: usize, cols: usize, data: Vec<T>) -> Self {
        assert_eq!(rows * cols, data.len());
        Self { cols, data }
    }

    fn get(&self, i: usize, j: usize) -> &T {
        &self.data[i * self.cols + j]
    }
}

#[derive(Debug)]
pub struct LanguageIdentifier {
    nb_classes: Vec<String>,
    nb_pc: Vec<f32>,
    nb_ptc: FlatArray<f32>,
    tk_nextmove: Vec<u16>,
    tk_output: TkOutput,
    num_feats: u32,
}

impl LanguageIdentifier {
    // NOTE: this fn is generated by claude
    pub fn from_reader<R: Read>(mut r: R) -> io::Result<Self> {
        let mut magic = [0u8; 4];
        r.read_exact(&mut magic)?;

        if &magic != b"LANG" {
            return Err(io::Error::new(
                io::ErrorKind::InvalidData,
                "Invalid magic bytes",
            ));
        }

        // Read counts
        let mut buf = [0u8; 4];
        r.read_exact(&mut buf)?;
        let num_classes = u32::from_le_bytes(buf);

        r.read_exact(&mut buf)?;
        let num_feats = u32::from_le_bytes(buf);

        // Read classes
        let mut nb_classes = Vec::with_capacity(num_classes as usize);
        for _ in 0..num_classes {
            r.read_exact(&mut buf)?;
            let len = u32::from_le_bytes(buf) as usize;
            let mut str_buf = vec![0u8; len];
            r.read_exact(&mut str_buf)?;
            nb_classes.push(
                String::from_utf8(str_buf)
                    .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?,
            );
        }

        // Read nb_pc
        let mut nb_pc = vec![0.0f32; num_classes as usize];
        r.read_exact(unsafe {
            std::slice::from_raw_parts_mut(nb_pc.as_mut_ptr() as *mut u8, nb_pc.len() * 4)
        })?;

        // Read nb_ptc
        r.read_exact(&mut buf)?;
        let rows = u32::from_le_bytes(buf) as usize;
        r.read_exact(&mut buf)?;
        let cols = u32::from_le_bytes(buf) as usize;

        let mut nb_ptc_data = vec![0.0f32; rows * cols];
        r.read_exact(unsafe {
            std::slice::from_raw_parts_mut(
                nb_ptc_data.as_mut_ptr() as *mut u8,
                nb_ptc_data.len() * 4,
            )
        })?;
        let nb_ptc = FlatArray::new(rows, cols, nb_ptc_data);

        // Read tk_nextmove
        r.read_exact(&mut buf)?;
        let nextmove_len = u32::from_le_bytes(buf) as usize;
        let mut tk_nextmove = vec![0u16; nextmove_len];
        r.read_exact(unsafe {
            std::slice::from_raw_parts_mut(
                tk_nextmove.as_mut_ptr() as *mut u8,
                tk_nextmove.len() * 2,
            )
        })?;

        // Read tk_output
        r.read_exact(&mut buf)?;
        let num_offsets = u32::from_le_bytes(buf) as usize;

        let mut offsets = Vec::with_capacity(num_offsets);
        for _ in 0..num_offsets {
            let mut offset_buf = [0u8; 8]; // For two u32s
            r.read_exact(&mut offset_buf)?;
            let offset = u32::from_le_bytes(offset_buf[0..4].try_into().unwrap());
            let length = u32::from_le_bytes(offset_buf[4..8].try_into().unwrap());
            offsets.push((offset, length));
        }

        r.read_exact(&mut buf)?;
        let values_len = u32::from_le_bytes(buf) as usize;
        let mut values = vec![0u16; values_len];
        r.read_exact(unsafe {
            std::slice::from_raw_parts_mut(values.as_mut_ptr() as *mut u8, values.len() * 2)
        })?;

        let tk_output = TkOutput { offsets, values };

        Ok(Self {
            nb_classes,
            nb_pc,
            nb_ptc,
            tk_nextmove,
            tk_output,
            num_feats,
        })
    }

    pub fn from_lzma_bytes<R: Read>(bytes: R) -> io::Result<Self> {
        let mut decompressed = vec![];
        let mut compressed_file = BufReader::new(bytes);
        lzma_rs::xz_decompress(&mut compressed_file, &mut decompressed)
            .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;
        Self::from_reader(Cursor::new(decompressed))
    }

    pub fn from_lzma_file<P: AsRef<Path>>(path: P) -> io::Result<Self> {
        Self::from_lzma_bytes(File::open(path)?)
    }

    pub fn new() -> io::Result<Self> {
        let model_bytes = include_bytes!("../resource/model.bin");
        Self::from_lzma_bytes(Cursor::new(model_bytes))
    }

    fn instance2fv<I: Iterator<Item = u8>>(&self, text: I) -> Vec<u16> {
        let mut state = 0;
        let mut count = vec![0; self.num_feats as usize];
        for letter in text {
            state = self.tk_nextmove[((state as usize) << 8) + letter as usize];
            for i in self.tk_output.get(state) {
                count[*i as usize] += 1;
            }
        }
        count
    }

    fn nb_classprobs(&self, fv: Vec<u16>) -> Vec<f32> {
        let mut pdc = vec![0.0; self.nb_classes.len()];
        // manual dot product
        for (i, v) in fv.into_iter().enumerate() {
            if v > 0 {
                for (j, w) in pdc.iter_mut().enumerate() {
                    *w += v as f32 * self.nb_ptc.get(i, j);
                }
            }
        }
        for (v, w) in pdc.iter_mut().zip(self.nb_pc.iter()) {
            *v += w;
        }
        pdc
    }

    pub fn classify(&self, text: &str) -> (String, f32) {
        let fv = self.instance2fv(text.as_bytes().iter().copied());
        let probs = self.nb_classprobs(fv);
        let cl = probs
            .iter()
            .enumerate()
            .max_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Less))
            .map(|(i, _)| i)
            .unwrap();
        (self.nb_classes[cl].clone(), probs[cl])
    }
}

#[cfg(test)]
mod tests {
    use super::LanguageIdentifier;

    fn f32_is_close(a: f32, b: f32, epsilon: f32) -> bool {
        (a - b).abs() < epsilon
    }

    #[test]
    fn test_classify() {
        let li = LanguageIdentifier::new().unwrap();
        for (text, (exp_lang, exp_prob)) in [
            ("你是我万水千山的冒险要找的标记点", ("zh", -256.80695)),
            ("あなたの体育の先生は誰ですか?", ("ja", -376.09363)),
            ("This text is in English.", ("en", -56.77429)),
        ] {
            let (lang, prob) = li.classify(text);
            assert_eq!(lang, exp_lang);
            assert!(f32_is_close(prob, exp_prob, 1e-4));
        }
    }
}
