from typing import Self
from py3langid.langid import LanguageIdentifier, MODEL_FILE
import struct
import numpy as np
from pathlib import Path
from io import BytesIO
import lzma


class TkOutput:
    # flattened representation of dict[int, tuple[int, ...]]
    def __init__(self) -> None:
        self.offsets: list[tuple[int, int]] = []
        self.values: list[int] = []

    def append(self, values: list[int]):
        self.offsets.append((len(self.values), len(values)))
        self.values.extend(values)

    @classmethod
    def from_ld(cls, ld: LanguageIdentifier) -> Self:
        tk_output = cls()
        for i in range(0, max(ld.tk_output.keys()) + 1):
            tk_output.append(ld.tk_output.get(i, ()))
        return tk_output


# NOTE: generated by claude
def serialize_model(li: LanguageIdentifier, tk_output: TkOutput, out_path: Path):
    """
    Binary format:
    - Magic bytes: b'LANG' (4 bytes)
    - Number of classes (4 bytes)
    - Number of features (4 bytes)
    - Classes list (each string prefixed with length)
    - nb_pc array (float32 array)
    - nb_ptc shape[0] (4 bytes)
    - nb_ptc shape[1] (4 bytes)
    - nb_ptc data (float32 array)
    - tk_nextmove length (4 bytes)
    - tk_nextmove data (uint16 array)
    - tk_output length (4 bytes)
    - tk_output data (array of arrays of uint16)
    """
    b = BytesIO()

    # Magic bytes
    b.write(b"LANG")

    # Write number of classes and features
    b.write(struct.pack("<II", len(li.nb_classes), li.nb_numfeats))

    # Write classes
    for class_name in li.nb_classes:
        encoded = class_name.encode("utf-8")
        b.write(struct.pack("<I", len(encoded)))
        b.write(encoded)

    # Write nb_pc
    nb_pc = li.nb_pc.astype(np.float32)
    b.write(nb_pc.tobytes())

    # Write nb_ptc
    b.write(struct.pack("<II", *li.nb_ptc.shape))
    nb_ptc = li.nb_ptc.astype(np.float32)
    b.write(nb_ptc.tobytes())

    # Write tk_nextmove
    tk_nextmove = np.array(li.tk_nextmove, dtype=np.uint16)
    b.write(struct.pack("<I", len(tk_nextmove)))
    b.write(tk_nextmove.tobytes())

    # Write tk_output
    # First write total number of entries
    b.write(struct.pack("<I", len(tk_output.offsets)))

    # Write all offsets as pairs of uint32
    for offset, length in tk_output.offsets:
        b.write(struct.pack("<II", offset, length))

    # Write all values as uint16
    values_array = np.array(tk_output.values, dtype=np.uint16)
    b.write(struct.pack("<I", len(values_array)))
    b.write(values_array.tobytes())

    # compressed = snappy.compress(b.getvalue())
    with lzma.open(out_path, "wb") as f:
        f.write(b.getvalue())


if __name__ == "__main__":
    li = LanguageIdentifier.from_pickled_model(MODEL_FILE)
    tk_output = TkOutput.from_ld(li)
    out_path = Path("resource/model.bin")
    out_path.parent.mkdir(exist_ok=True)
    serialize_model(li, tk_output, out_path)
